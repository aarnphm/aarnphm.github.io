import numpy as np
import matplotlib.pyplot as plt
import control

# Given requirements
OS = 0.10  # 10% overshoot
Ts = 0.5  # 0.5 second settling time

# Calculating damping ratio (zeta) from overshoot
zeta = np.sqrt(np.log(OS) ** 2 / (np.pi**2 + np.log(OS) ** 2))

# Calculating natural frequency (omega_n) from settling time and damping ratio
wn = 4 / (zeta * Ts)

print('zeta:', zeta, 'omega_n:', wn)

# Define the plant model
A = np.array([[-1, 1], [0, 2]])
B = np.array([[0], [1]])
C = np.array([[1, 1]])
D = 0

# Create state space model
sys = control.ss(A, B, C, D)
print(sys)

# Augment the plant with an integrator
A_aug = np.block([[A, np.zeros((2, 1))], [-C, 0]])
B_aug = np.block([[B], [0]])
C_aug = np.block([[C, 0]])
D_aug = np.array([[0]])
plant_aug = control.ss(A_aug, B_aug, C_aug, D_aug)

# Desired closed-loop poles for 10% overshoot and 0.5s settling time
desired_poles = np.roots([1, 2 * zeta * wn, wn**2])
desired_poles = np.append(desired_poles, -10 * np.max(np.abs(desired_poles)))

print('Desired poles:', desired_poles)

# Find state feedback gains using pole placement
K = control.place(A_aug, B_aug, desired_poles)
print(K)
print(f'State feedback gain K = {K.gain_matrix}')

# Form the closed-loop system with integral action
sys_cl = control.ss(A_aug - B_aug * K.gain_matrix, B_aug, C_aug, 0)

# Scale the input for zero steady-state error
Nbar = -1 / control.dcgain(sys_cl)
sys_cl_scaled = control.ss(A_aug - B_aug * K.gain_matrix, B_aug * Nbar, C_aug, 0)

# Simulate the closed-loop response to a step input
t = np.linspace(0, 3, 500)
r = np.ones_like(t)
y, _, _ = control.forced_response(sys_cl_scaled, t, r)

# Plot the results
plt.figure()
plt.plot(t, r, label='Reference')
plt.plot(t, y, label='Output')
plt.xlabel('Time (s)')
plt.ylabel('Position')
plt.title('Closed-loop response with integral control')
plt.legend()
plt.grid()
plt.show()
